@startuml PDF_to_Audio_Component_Interactions
!theme plain
skinparam sequenceArrowThickness 2
skinparam roundcorner 20
skinparam maxmessagesize 60
skinparam sequenceParticipant underline

title PDF to Audio Processing Flow\n(Clean Architecture - Post YOLO)

actor User
participant "Flask Routes" as Routes
participant "Service Factory" as Factory
participant "DocumentEngine" as DocEngine
participant "TextPipeline" as TextPipe
participant "AudioEngine" as AudioEngine
participant "TimingEngine" as TimingEngine
participant "TTS Provider" as TTS
participant "File Manager" as FileManager

User -> Routes : Upload PDF
Routes -> Factory : create_pdf_service_from_env()
Factory -> DocEngine : new DocumentEngine()
Factory -> AudioEngine : new AudioEngine()
Factory -> TextPipe : new TextPipeline()
Factory -> Routes : ServiceContainer

Routes -> DocEngine : get_pdf_info(pdf_path)
DocEngine -> Routes : PDFInfo

Routes -> DocEngine : process_document(request, audio_engine, text_pipeline)

activate DocEngine
DocEngine -> DocEngine : extract_text(pdf_path, pages)
note right : OCR fallback for poor quality

DocEngine -> TextPipe : clean_text(raw_text)
TextPipe -> TextPipe : _basic_text_cleanup() or LLM cleaning
TextPipe -> DocEngine : cleaned_text

DocEngine -> TextPipe : enhance_with_ssml(cleaned_text)
TextPipe -> TextPipe : _add_academic_pauses()\n_enhance_technical_terms()
TextPipe -> DocEngine : enhanced_text

DocEngine -> AudioEngine : generate_with_timing(processed_chunks, output_name)

activate AudioEngine
AudioEngine -> TimingEngine : generate_with_timing(chunks, filename)

activate TimingEngine
TimingEngine -> TimingEngine : _generate_with_estimation() or\n_generate_with_measurement()

alt Estimation Mode (Fast)
  TimingEngine -> TTS : generate_audio_with_timestamps(full_text)
  TTS -> TimingEngine : (audio_data, text_segments)
else Measurement Mode (Accurate)
  TimingEngine -> TimingEngine : _generate_audio_files_concurrent()
  loop for each sentence batch
    TimingEngine -> TTS : generate_audio_data(batch_text)
    TTS -> TimingEngine : audio_data
    TimingEngine -> FileManager : save_temp_file(audio_data)
    TimingEngine -> TimingEngine : _measure_audio_duration()
  end
  TimingEngine -> TimingEngine : _combine_audio_files()
end

TimingEngine -> FileManager : save_output_file(audio_data, filename)
FileManager -> TimingEngine : output_path
TimingEngine -> AudioEngine : TimedAudioResult
deactivate TimingEngine

AudioEngine -> DocEngine : TimedAudioResult
deactivate AudioEngine

DocEngine -> Routes : ProcessingResult(success=true, audio_files, debug_info)
deactivate DocEngine

Routes -> User : Render success page with audio files

note over User, FileManager
ðŸŽ¯ **Clean Architecture Benefits**
â€¢ Single Responsibility: Each component has one job
â€¢ Dependency Inversion: High-level modules don't depend on low-level
â€¢ Interface Segregation: Clean contracts between components  
â€¢ Open/Closed: Easy to extend without modifying existing code
end note

@enduml