@startuml PDF_to_Audio_Simplified_Architecture

skinparam packageStyle rectangle
skinparam classAttributeIconSize 0
skinparam shadowing false

package "Web Layer" #DDDDDD {
    class FlaskApp {
        +upload_file()
        +get_pdf_info()
        +serve_audio()
    }
}

package "Application Layer" #CCCCFF {
    class PDFProcessingService {
        +process_pdf()
        +get_pdf_info()
        +validate_page_range()
    }
    
    class SystemConfig {
        +tts_engine: TTSEngine
        +enable_text_cleaning: bool
        +audio_folder: str
        --
        +from_env(): SystemConfig
    }
    
    class CompositionRoot {
        +create_pdf_service_from_env()
    }
    
    enum TTSEngine {
        PIPER
        GEMINI
    }
}

package "Domain Layer" #CCFFCC {
    
    class ProcessingRequest {
        +pdf_path: str
        +output_name: str
        +page_range: PageRange
    }
    
    class ProcessingResult {
        +audio_files: List[str]
        +combined_mp3_file: str
        +error: ApplicationError
    }
    
    interface ITTSEngine {
        +generate_audio_data(text): bytes
        +get_output_format(): str
    }
    
    interface ILLMProvider {
        +generate_content(prompt): str
    }
    
    interface TextExtractor {
        +extract_text(pdf_path, page_range): str
    }
    
    interface TextCleaner {
        +clean_text(raw_text): List[str]
    }
    
    interface AudioGenerator {
        +generate_audio(chunks): Tuple[List[str], str]
    }
    
    interface FileManager {
        +cleanup_old_files(): CleanupResult
        +schedule_cleanup(): bool
    }
    
    class TextCleaningService {
        +clean_text()
    }
    
    class AudioGenerationService {
        +generate_audio()
    }
    
    class AcademicSSMLService {
        +enhance_text_chunks()
    }
}

package "Infrastructure Layer" #FFCCFF {
    
    class GeminiTTSProvider {
        +generate_audio_data()
        +supports_ssml(): bool
    }
    
    class PiperTTSProvider {
        +generate_audio_data()
        +supports_ssml(): bool
    }
    
    class GeminiLLMProvider {
        +generate_content()
    }
    
    class TesseractOCRProvider {
        +extract_text()
        +get_pdf_info()
    }
    
    class LocalFileManager {
        +cleanup_old_files()
        +schedule_cleanup()
    }
    
    class FileCleanupScheduler {
        +start()
        +stop()
    }
}

' === MAIN FLOW ===
FlaskApp --> PDFProcessingService : orchestrates
PDFProcessingService --> ProcessingRequest : processes
PDFProcessingService --> ProcessingResult : returns

' === COMPOSITION ===
CompositionRoot --> PDFProcessingService : creates
CompositionRoot --> SystemConfig : reads

' === SERVICE DEPENDENCIES ===
PDFProcessingService --> TextExtractor : uses
PDFProcessingService --> TextCleaner : uses
PDFProcessingService --> AudioGenerator : uses
PDFProcessingService --> FileManager : uses

' === DOMAIN SERVICES ===
TextCleaningService ..|> TextCleaner
AudioGenerationService ..|> AudioGenerator

TextCleaningService --> ILLMProvider : uses
AudioGenerationService --> ITTSEngine : uses
AudioGenerationService --> FileManager : uses
AcademicSSMLService --> ITTSEngine : uses

' === INFRASTRUCTURE IMPLEMENTATIONS ===
GeminiTTSProvider ..|> ITTSEngine
PiperTTSProvider ..|> ITTSEngine
GeminiLLMProvider ..|> ILLMProvider
TesseractOCRProvider ..|> TextExtractor
LocalFileManager ..|> FileManager

' === CONFIGURATION ===
SystemConfig --> TTSEngine : defines
FileCleanupScheduler --> FileManager : manages
FileCleanupScheduler --> SystemConfig : reads

' === NOTES ===
note top of PDFProcessingService : Main Business Logic\nOrchestrator
note top of CompositionRoot : Dependency Injection\n& Service Assembly
note bottom of ITTSEngine : Strategy Pattern:\nPiper (Local) vs Gemini (Cloud)
note bottom of FileManager : Automated File Lifecycle\nManagement

@enduml