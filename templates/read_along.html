{% extends "base.html" %}
{% block title %}READ-ALONG MODE - NICOLAIS PDF2WAV{% endblock %}
{% block content %}
    <h1>‚óÜ READ-ALONG MODE ‚óÜ</h1>
    
    <div class="read-along-container">
        <div class="audio-controls-section">
            <h3>‚ô´ AUDIO PLAYBACK CONTROLS ‚ô´</h3>
            <div class="main-audio-player">
                <audio id="mainAudio" controls preload="metadata">
                    <source src="{{ url_for('serve_audio', filename=audio_filename) }}" type="audio/{{ 'mpeg' if audio_filename.endswith('.mp3') else 'wav' }}">
                    YOUR BROWSER DOES NOT SUPPORT AUDIO PLAYBACK.
                </audio>
            </div>
            
            <div class="playback-info">
                <div class="time-display">
                    <span id="currentTime">00:00</span> / <span id="totalTime">00:00</span>
                </div>
                <div class="sync-controls">
                    <button id="toggleAutoScroll" class="control-btn">AUTO-SCROLL: ON</button>
                    <button id="resumeTracking" class="control-btn" style="display: none;">RESUME TRACKING</button>
                </div>
            </div>
        </div>

        <div class="text-display-section">
            <h3>üìÑ DOCUMENT TEXT</h3>
            <div id="textContainer" class="text-container">
                <p class="loading-text">LOADING TEXT SYNCHRONIZATION...</p>
            </div>
        </div>
    </div>

    <div class="rainbow-divider"></div>
    
    <div class="instructions">
        <h4><span class="icon">‚ñ∫</span>READ-ALONG INSTRUCTIONS</h4>
        <ul>
            <li>TEXT WILL HIGHLIGHT AUTOMATICALLY AS AUDIO PLAYS</li>
            <li>CLICK ANY SENTENCE TO JUMP AUDIO TO THAT POSITION</li>
            <li>SCROLL MANUALLY TO DISABLE AUTO-SCROLL</li>
            <li>CLICK "RESUME TRACKING" TO RE-SYNC TEXT WITH AUDIO</li>
            <li>USE AUDIO CONTROLS FOR PLAY/PAUSE/VOLUME/SPEED</li>
        </ul>
    </div>

    <div style="text-align: center; margin-top: 40px;">
        <a href="{{ url_for('index') }}" class="back-btn">
            << BACK TO CONVERTER
        </a>
    </div>

{% endblock %}

{% block scripts %}
<script>
    class ReadAlongPlayer {
        constructor(timingApiUrl, audioElement) {
            this.timingApiUrl = timingApiUrl;
            this.audio = audioElement;
            this.segments = [];
            this.currentSegmentIndex = -1;
            this.autoScroll = true;
            this.isUserSeeking = false;
            
            this.initializeElements();
            this.loadTimingData();
            this.setupEventListeners();
        }
        
        initializeElements() {
            this.textContainer = document.getElementById('textContainer');
            this.currentTimeDisplay = document.getElementById('currentTime');
            this.totalTimeDisplay = document.getElementById('totalTime');
            this.toggleAutoScrollBtn = document.getElementById('toggleAutoScroll');
            this.resumeTrackingBtn = document.getElementById('resumeTracking');
        }
        
        async loadTimingData() {
            try {
                const response = await fetch(this.timingApiUrl);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const timingData = await response.json();
                this.segments = timingData.text_segments || [];
                this.renderText();
                
                console.log(`Loaded ${this.segments.length} text segments`);
            } catch (error) {
                console.error('Failed to load timing data:', error);
                this.textContainer.innerHTML = `
                    <p style="color: #FBFE65; text-align: center;">
                        ‚ùå FAILED TO LOAD TIMING DATA<br>
                        Error: ${error.message}
                    </p>
                `;
            }
        }
        
        renderText() {
            if (this.segments.length === 0) {
                this.textContainer.innerHTML = '<p style="color: #FBFE65;">No text segments available.</p>';
                return;
            }
            
            const textHtml = this.segments.map((segment, index) => 
                `<span class="text-segment" data-index="${index}" data-start="${segment.start_time}">
                    ${this.escapeHtml(segment.text)}
                </span>`
            ).join(' ');
            
            this.textContainer.innerHTML = textHtml;
            
            // Add click listeners to segments
            this.textContainer.querySelectorAll('.text-segment').forEach(segment => {
                segment.addEventListener('click', (e) => {
                    const startTime = parseFloat(e.target.dataset.start);
                    this.seekToTime(startTime);
                });
            });
        }
        
        setupEventListeners() {
            // Audio time updates
            this.audio.addEventListener('timeupdate', () => {
                if (!this.isUserSeeking) {
                    this.updateHighlight();
                    this.updateTimeDisplay();
                }
            });
            
            // Audio loaded
            this.audio.addEventListener('loadedmetadata', () => {
                this.updateTimeDisplay();
            });
            
            // User seeking
            this.audio.addEventListener('seeking', () => {
                this.isUserSeeking = true;
            });
            
            this.audio.addEventListener('seeked', () => {
                this.isUserSeeking = false;
                this.updateHighlight();
            });
            
            // Control buttons
            this.toggleAutoScrollBtn.addEventListener('click', () => {
                this.toggleAutoScroll();
            });
            
            this.resumeTrackingBtn.addEventListener('click', () => {
                this.resumeTracking();
            });
            
            // Scroll detection
            this.textContainer.addEventListener('scroll', () => {
                if (this.autoScroll) {
                    this.autoScroll = false;
                    this.updateAutoScrollButton();
                    this.resumeTrackingBtn.style.display = 'inline-block';
                }
            });
        }
        
        updateHighlight() {
            const currentTime = this.audio.currentTime;
            let activeIndex = -1;
            
            // Find current segment
            for (let i = 0; i < this.segments.length; i++) {
                const segment = this.segments[i];
                if (currentTime >= segment.start_time && 
                    currentTime < segment.start_time + segment.duration) {
                    activeIndex = i;
                    break;
                }
            }
            
            // Update segment highlighting
            this.textContainer.querySelectorAll('.text-segment').forEach((element, index) => {
                element.classList.remove('active', 'completed');
                
                if (index === activeIndex) {
                    element.classList.add('active');
                } else if (index < activeIndex) {
                    element.classList.add('completed');
                }
            });
            
            // Auto-scroll to active segment
            if (activeIndex !== -1 && this.autoScroll && activeIndex !== this.currentSegmentIndex) {
                const activeElement = this.textContainer.querySelector(`[data-index="${activeIndex}"]`);
                if (activeElement) {
                    activeElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                }
            }
            
            this.currentSegmentIndex = activeIndex;
        }
        
        updateTimeDisplay() {
            this.currentTimeDisplay.textContent = this.formatTime(this.audio.currentTime);
            this.totalTimeDisplay.textContent = this.formatTime(this.audio.duration || 0);
        }
        
        formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        seekToTime(time) {
            this.audio.currentTime = time;
            this.updateHighlight();
        }
        
        toggleAutoScroll() {
            this.autoScroll = !this.autoScroll;
            this.updateAutoScrollButton();
            
            if (this.autoScroll) {
                this.resumeTrackingBtn.style.display = 'none';
                this.updateHighlight(); // Re-scroll to current position
            }
        }
        
        updateAutoScrollButton() {
            this.toggleAutoScrollBtn.textContent = `AUTO-SCROLL: ${this.autoScroll ? 'ON' : 'OFF'}`;
        }
        
        resumeTracking() {
            this.autoScroll = true;
            this.updateAutoScrollButton();
            this.resumeTrackingBtn.style.display = 'none';
            this.updateHighlight();
        }
        
        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    }
    
    // Initialize read-along player
    document.addEventListener('DOMContentLoaded', function() {
        const audioElement = document.getElementById('mainAudio');
        const timingApiUrl = '{{ timing_api_url }}';
        
        const player = new ReadAlongPlayer(timingApiUrl, audioElement);
        
        console.log('Read-along player initialized');
        console.log('Timing API URL:', timingApiUrl);
        console.log('Audio file:', '{{ audio_filename }}');
    });
</script>
{% endblock %}